/*
Kevin Stich
Programmer Application
Neighborhood Board Code Test
*/

#include <iostream>
#include <time.h>
using namespace std;

int neighborhoodSize(char*);
void recurseMove(unsigned char, bool*, unsigned short int&);

//Sample main routine to utilize the calculation
int main() {
	//clock_t objects used to calculate time for the algorithm
	clock_t start, end;
	//Sample board
	char test[256] = {
		0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1
	};
	cout << "Here's the board:" << endl;
	//Print the char array
	int i = 0;
	while (i < 256) {
		if(test[i]) {
			cout << 'X';
		} else {
			cout << 'O';
		}
		if ((i & 0xF) == 0xF) {
			cout << endl;
		}
		i++;
	}

	//Perform and print the calculation of neighborhood size
	cout << "Size of the largest neighborhood is: " << neighborhoodSize(test) << endl << endl;

	//Get the current clock before it starts calculating
	cout << "Starting 1000000 calculations... ";
	start = clock();

	//Run the algorithm 1000000 times for timing purposes
	for(i=0;i<1000000;i++) {
		neighborhoodSize(test);
	}
	//Get the current clock after it's finished calculating
	end = clock();
	cout << "Finished." << endl << endl;

	//Print the time it took to run the algorithm
	cout << "Time: " << (double)(end-start)/CLOCKS_PER_SEC << "s" << endl;
	cout << "Average time per calculation: " << ((double)(end-start)/CLOCKS_PER_SEC)/(double)1000000 << "s" << endl << endl;

	//Pause for display
	system("PAUSE");
	return 0;
}

//Method that calculates the max neighborhood size
int neighborhoodSize(char *board) {
	//Boolean copy so we can manipulate the board
	bool* boardCopy = new bool[256];
	//Current size and max size
	unsigned short int size, max=0;
	//Copy the board into the boolean board
	//Because the null character 0 is the value 0, we can convert it to a boolean board where all empty spaces evaluate to false and occupied spaces evaluate to true
	memcpy(boardCopy, board, 256);
	//Loop to run through the positions of the board
	for(unsigned char pos = 0; pos <= 255; pos++) {
		//Jump into the recursive check if the current position is occupied by something other than a null character
		if(boardCopy[pos]) {
			//Reset the size of the neighborhood to 0
			size = 0;
			//Start recursivly traversing the board
			recurseMove(pos, boardCopy, size);
			//Replace the max size
			if(size>max) {
				max = size;
			}
		}
		if(pos==255) {
			break;
		}
	}
	//Delete the copy of the board that was dynamically allocated
	delete boardCopy;
	//Return the maximum neighborhood size
	return (int)max;
}
//Method to recursively crawl non-null characters in the array
void recurseMove(unsigned char p, bool *b, unsigned short int &s) {
	//Add one to size and set this position to false
	s++;
	b[p] = false;
	//Check to make sure we aren't in the first row,
	//then that there is something above us. If there, recurse into that spot
	if(p>15 && b[p-16]) {
		recurseMove(p-16, b, s);
	}
	//Check to make sure we aren't in the left column,
	//then that there is something to the left of us. If there, recurse into that spot
	if(((p&0xF)!=0x0) && b[p-1]) {
		recurseMove(p-1, b, s);
	}
	//Check to make sure we aren't in the bottom row,
	//then that there is something below us. If there, recurse into that spot
	if(p<240 && b[p+16]) {
		recurseMove(p+16, b, s);
	}
	//Check to make sure we aren't in the right column,
	//then that there is something to the right of us. If there, recurse into that spot
	if(((p&0xF)!=0xF) && b[p+1]) {
		recurseMove(p+1, b, s);
	}
}